package triblab

import (
    "errors"
    "fmt"
    "sort"
    "time"
    "trib"
)

type Tribber struct {
    binStorage trib.BinStorage
}
var _ trib.Server = new(Tribber)

const users_list_key    = "USERS_LIST"
const existed_key       = "EXISTED"
const tribble_list_key  = "TRIBBLE_LIST"
const follow_list_key   = "FOLLOW_LIST"

// Creates a user.
// Returns error when the username is invalid;
// returns error when the user already exists.
// Concurrent sign ups on the same user might both succeed with no error.
func (self *Tribber) SignUp(user string) error {
    if trib.IsValidUsername(user) == false {
        return errors.New(fmt.Sprintf("SignUp::Invalid username '%s'.", user))
    }
    storage := self.binStorage.Bin(users_list_key)
    var exist string
    err := storage.Get(user, &exist)
    if err != nil {
        return err
    }
    if exist != "" {
        return errors.New(fmt.Sprintf("SignUp::Username '%s' already exists.", user))
    }
    var succ bool
    err = storage.Set(&trib.KeyValue{ user, existed_key }, &succ)
    if err != nil {
        return err
    }
    if succ == false {
        return errors.New(fmt.Sprintf("SignUp::Failed due to Storage error."))
    }
    return nil
}

// List 20 registered users.  When there are less than 20 users that
// signed up the service, all of them needs to be listed.  When there
// are more than 20 users that signed up the service, an arbitrary set
// of at lest 20 of them needs to be listed.
// The result should be sorted in alphabetical order.
func (self *Tribber) ListUsers() ([]string, error) {
    storage := self.binStorage.Bin(users_list_key)
    userList := new(trib.List)
    err := storage.Keys(&trib.Pattern{ "", "" }, userList)
    if err != nil {
        return []string{}, err
    }
    if len(userList.L) > trib.MinListUser {
        userList.L = userList.L[0:trib.MinListUser]
    }
    sort.Strings(userList.L)
    return userList.L, nil
}

// Post a tribble.  The clock is the maximum clock value this user has
// seen so far by reading tribbles or clock sync.
// Returns error when who does not exist;
// returns error when post is too long.
func (self *Tribber) Post(who, post string, clock uint64) error {
    if len(post) > trib.MaxTribLen {
        return errors.New(fmt.Sprintf("Post::Post '%s' has %d characters, too long.", len(post), post))
    }
    userList := self.binStorage.Bin(users_list_key)
    var exist string
    err := userList.Get(who, &exist)
    if err != nil {
        return err
    }
    if exist == "" {
        return errors.New(fmt.Sprintf("Post::User '%s' does not exist.", who))
    }

    storage := self.binStorage.Bin(who)
    var newClock uint64
    err = storage.Clock(clock, &newClock)
    if err != nil {
        return err
    }

    var succ bool
    var newPost string
    newPost, err = TribToString(&trib.Trib{who, post, time.Now(), newClock})
    if err != nil {
        return err
    }
    err = storage.ListAppend(&trib.KeyValue{tribble_list_key, newPost}, &succ)
    if err != nil {
        return err
    }
    if succ == false {
        return errors.New(fmt.Sprintf("Post::Failed due to Storage error."))
    }
    return nil
}

// List the tribs that a particular user posted.
// Returns error when user has not signed up.
func (self *Tribber) Tribs(user string) ([]*trib.Trib, error) {
    userList := self.binStorage.Bin(users_list_key)
    var exist string
    err := userList.Get(user, &exist)
    if err != nil {
        return []*trib.Trib{}, err
    }
    if exist == "" {
        return []*trib.Trib{}, errors.New(fmt.Sprintf("Tribs::User '%s' does not exist.", user))
    }
    storage := self.binStorage.Bin(user)
    userTribbleList := new(trib.List)
    err = storage.ListGet(tribble_list_key, userTribbleList)
    if err != nil {
        return []*trib.Trib{}, err
    }
    ret := []*trib.Trib{}
    var tribbler *trib.Trib
    for _, element := range userTribbleList.L {
        tribbler, err = StringToTrib(element)
        if err != nil {
            return []*trib.Trib{}, err
        }
        ret = append(ret, tribbler)
    }

    sort.Sort(TribblerOrder(ret))
    if len(ret) > trib.MaxTribFetch {
        ret = ret[len(ret)-trib.MaxTribFetch:len(ret)]
    }
    return ret, nil
}

// Follow someone's timeline.
// Returns error when who == whom;
// returns error when who is already following whom;
// returns error when who is tryting to following
// more than trib.MaxFollowing users.
// returns error when who or whom has not signed up.
// Concurrent follows might both succeed without error.
// The count of following users might exceed trib.MaxFollowing=2000,
// if and only if the 2000'th user is generated by concurrent Follow()
// calls.
func (self *Tribber) Follow(who, whom string) error {
    if who == whom {
        return errors.New(fmt.Sprintf("Follow::Who and whom cannot be the same."))
    }
    userList := self.binStorage.Bin(users_list_key)
    var exist string
    err := userList.Get(who, &exist)
    if err != nil {
        return err
    }
    if exist == "" {
        return errors.New(fmt.Sprintf("Follow::User '%s' does not exist.", who))
    }
    err = userList.Get(whom, &exist)
    if err != nil {
        return err
    }
    if exist == "" {
        return errors.New(fmt.Sprintf("Follow::User '%s' does not exist.", whom))
    }

    storage := self.binStorage.Bin(who)
    follow_list := new(trib.List)
    err = storage.ListGet(follow_list_key, follow_list)
    if err != nil {
        return err
    }
    if len(follow_list.L) > trib.MaxFollowing {
        return errors.New(fmt.Sprintf("Follow::Exceed max following number %d", trib.MaxFollowing))
    }
    for _, element := range follow_list.L {
        if element == whom {
            return errors.New(fmt.Sprintf("Follow::User '%s' is already following '%s'.", who, whom))
        }
    }
    var succ bool
    err = storage.ListAppend(&trib.KeyValue{follow_list_key, whom}, &succ)
    if err != nil {
        return err
    }
    if succ == false {
        return errors.New(fmt.Sprintf("Follow::Failed due to Storage error."))
    }
    return nil
}

// Unfollow someone's timeline.
// Returns error when who == whom.
// returns error when who is not following whom;
// returns error when who or whom has not signed up.
func (self *Tribber) Unfollow(who, whom string) error {
    if who == whom {
        return errors.New(fmt.Sprintf("Unfollow::Who and whom cannot be the same."))
    }
    userList := self.binStorage.Bin(users_list_key)
    var exist string
    err := userList.Get(who, &exist)
    if err != nil {
        return err
    }
    if exist == "" {
        return errors.New(fmt.Sprintf("Unfollow::User '%s' does not exist.", who))
    }
    err = userList.Get(whom, &exist)
    if err != nil {
        return err
    }
    if exist == "" {
        return errors.New(fmt.Sprintf("Unfollow::User '%s' does not exist.", whom))
    }

    storage := self.binStorage.Bin(who)
    follow_list := new(trib.List)
    err = storage.ListGet(follow_list_key, follow_list)
    if err != nil {
        return err
    }
    var removed int
    for _, element := range follow_list.L {
        if element == whom {
            err = storage.ListRemove(&trib.KeyValue{follow_list_key, element}, &removed)
            if err != nil {
                return err
            }
            if removed != 1 {
                return errors.New(fmt.Sprintf("Unfollow::Remove more than one person."))
            }
            return nil
        }
    }
    return errors.New(fmt.Sprintf("UnFollow::User '%s' is not currently following '%s'", who, whom))
}

// Returns true when who following whom.
// Returns error when who == whom.
// Returns error when who or whom has not signed up.
func (self *Tribber) IsFollowing(who, whom string) (bool, error) {
    if who == whom {
        return false, errors.New(fmt.Sprintf("IsFollowing::Who and whom cannot be the same."))
    }
    userList := self.binStorage.Bin(users_list_key)
    var exist string
    err := userList.Get(who, &exist)
    if err != nil {
        return false, err
    }
    if exist == "" {
        return false, errors.New(fmt.Sprintf("IsFollowing::User '%s' does not exist.", who))
    }
    err = userList.Get(whom, &exist)
    if err != nil {
        return false, err
    }
    if exist == "" {
        return false, errors.New(fmt.Sprintf("IsFollowing::User '%s' does not exist.", whom))
    }

    storage := self.binStorage.Bin(who)
    follow_list := new(trib.List)
    err = storage.ListGet(follow_list_key, follow_list)
    if err != nil {
        return false, err
    }

    for _, element := range follow_list.L {
        if element == whom {
            return true, nil
        }
    }
    return false, nil
}

// Returns the list of following users.
// Returns error when who has not signed up.
// The list have users more than trib.MaxFollowing=2000,
// if and only if the 2000'th user is generate d by concurrent Follow()
// calls.
func (self *Tribber) Following(who string) ([]string, error) {
    userList := self.binStorage.Bin(users_list_key)
    var exist string
    err := userList.Get(who, &exist)
    if err != nil {
        return []string{}, err
    }
    if exist == "" {
        return []string{}, errors.New(fmt.Sprintf("Following::User '%s' does not exist.", who))
    }

    storage := self.binStorage.Bin(who)
    follow_list := new(trib.List)
    err = storage.ListGet(follow_list_key, follow_list)
    if err != nil {
        return []string{}, err
    }

    return follow_list.L, nil
}

// List the tribs of someone's following users (including himself).
// Returns error when user has not signed up.
func (self *Tribber) Home(user string) ([]*trib.Trib, error) {
    userList := self.binStorage.Bin(users_list_key)
    var exist string
    err := userList.Get(user, &exist)
    if err != nil {
        return []*trib.Trib{}, err
    }
    if exist == "" {
        return []*trib.Trib{}, errors.New(fmt.Sprintf("Home::User %s does not exist.", user))
    }

    storage := self.binStorage.Bin(user)
    follow_list := new(trib.List)
    err = storage.ListGet(follow_list_key, follow_list)
    if err != nil {
        return []*trib.Trib{}, err
    }

    following_users := append(follow_list.L, user)
    ret := []*trib.Trib{}
    for _, name := range following_users {
        name_storage := self.binStorage.Bin(name)
        name_tribble_list := new(trib.List)
        err = name_storage.ListGet(tribble_list_key, name_tribble_list)
        if err != nil {
            return []*trib.Trib{}, err
        }
        for _, name_tribble := range name_tribble_list.L {
            tribble, err := StringToTrib(name_tribble)
            if err != nil {
                return []*trib.Trib{}, err
            }
            ret = append(ret, tribble)
        }
    }
    sort.Sort(TribblerOrder(ret))
    if len(ret) > trib.MaxTribFetch {
        ret = ret[len(ret)-trib.MaxTribFetch:len(ret)]
    }
    return ret, nil
}

